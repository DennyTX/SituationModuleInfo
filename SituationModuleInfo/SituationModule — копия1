using System;
using System.Collections.Generic;
using System.Linq;
using KspHelper.Behavior;
using UnityEngine;

namespace SituationModuleInfo
{
    // указываем что аддон активируется 1 раз при входе в любой едитор (VAB, SPH)
    [KSPAddon(KSPAddon.Startup.EditorAny, true)] 
    public class SituationModule : KspBehavior
    {
        // создаем эталлонный список ситуаций, который будем менять 
        private readonly string[] _etalonSituationMask = new string[6]  
        {
            "Flying High: <b><color=red>X</color></b>",
            "Flying Low: <b><color=red>X</color></b>",
            "In Space High: <b><color=red>X</color></b>",
            "In Space Low: <b><color=red>X</color></b>",
            "Landed: <b><color=red>X</color></b>",
            "Splashed: <b><color=red>X</color></b>"
        };

        // создаем тип лист для списка партов
        private List<AvailablePart> _partsWithScience = new List<AvailablePart>(); 

        protected override void Start()
        {
            // переопределяем стандартный метод запускающийся при старте (добавляем свой действия)
            SituationMaskAnalys(); 
        }

        private void SituationMaskAnalys()
        {
            //получаем в ранее созданный объект типа список перечень партов, имеющих ModuleScienceExperiment или модуль с этим родителем 
            _partsWithScience = PartLoader.LoadedPartsList.Where(p => p.partPrefab.Modules.GetModules<ModuleScienceExperiment>().Any()).ToList(); 
            //_parts = PartLoader.LoadedPartsList.Where(p => p.partPrefab.Modules.Contains("ModuleScienceExperiment")).ToList(); //только парты с указанным модулем

            //цикл. перебираем все элементы в полученном ранее списке
            foreach (var part in _partsWithScience)  
            {
                //Debug.Log("====================================== SituationMaskAnalys ======== " + _partsWithScience.Count());
                //Debug.Log("====================================== foreach _partsWithScience == " + part.name);
                // получаем в список все нужные модули (ModuleScienceExperiment и детки) в рамках парта
                var modules = part.partPrefab.Modules.GetModules<ModuleScienceExperiment>();

                //цикл. перебираем полученные модули. этот цикл имеет смысл если модулей больше одного 
                foreach (var moduleScienceExperiment in modules) 
                {
                    //получаем каждый эксперимент
                    ScienceExperiment experiment = ResearchAndDevelopment.GetExperiment(moduleScienceExperiment.experimentID);
                    //Debug.Log("====================================== modules==================== " + modules.Count());
                    //Debug.Log("====================================== foreach modules =========== " + moduleScienceExperiment.experimentActionName); 
                    //Debug.Log("====================================== experiment ================ " + experiment.experimentTitle);
                    //создаем новую строку которую потом будем ложить в блок инфы в ЮИ парта в ВАБ
                    var itemInfo = new string[6];

                    // копируем эталонную запись и начинаем ее менять. Разборка битовыми операциями (поиск соответствия)
                    Array.Copy(_etalonSituationMask, itemInfo, 6);

                    if ((experiment.situationMask & (uint)ExperimentSituations.FlyingHigh) ==
                        (uint)ExperimentSituations.FlyingHigh)
                    {
                        itemInfo[0] = "Flying High: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.FlyingHigh) ==
                    (uint)ExperimentSituations.FlyingHigh)
                    {
                        itemInfo[0] = "Flying High: <b><color=green>V</color> Biome Depending</b>";
                    }

                    if ((experiment.situationMask & (uint)ExperimentSituations.FlyingLow) ==
                        (uint)ExperimentSituations.FlyingLow)
                    {
                        itemInfo[1] = "Flying Low: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.FlyingLow) ==
                    (uint)ExperimentSituations.FlyingLow)
                    {
                        itemInfo[1] = "Flying Low: <b><color=green>V</color> Biome Depending</b>";
                    }

                    if ((experiment.situationMask & (uint)ExperimentSituations.InSpaceHigh) ==
                        (uint)ExperimentSituations.InSpaceHigh)
                    {
                        itemInfo[2] = "Space High: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.InSpaceHigh) ==
                    (uint)ExperimentSituations.InSpaceHigh)
                    {
                        itemInfo[2] = "Space High: <b><color=green>V</color> Biome Depending</b>";
                    }

                    if ((experiment.situationMask & (uint)ExperimentSituations.InSpaceLow) ==
                        (uint)ExperimentSituations.InSpaceLow)
                    {
                        itemInfo[3] = "Space Low: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.InSpaceLow) ==
                    (uint)ExperimentSituations.InSpaceLow)
                    {
                        itemInfo[3] = "Space Low: <b><color=green>V</color> Biome Depending</b>";
                    }

                    if ((experiment.situationMask & (uint)ExperimentSituations.SrfLanded) ==
                        (uint)ExperimentSituations.SrfLanded)
                    {
                        itemInfo[4] = "Landed: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.SrfLanded) ==
                    (uint)ExperimentSituations.SrfLanded)
                    {
                        itemInfo[4] = "Landed: <b><color=green>V</color> Biome Depending</b>";
                    }

                    if ((experiment.situationMask & (uint)ExperimentSituations.SrfSplashed) ==
                        (uint)ExperimentSituations.SrfSplashed)
                    {
                        itemInfo[5] = "Splashed: <b><color=green>V</color></b>";
                    }

                    if ((experiment.biomeMask & (uint)ExperimentSituations.SrfSplashed) ==
                    (uint)ExperimentSituations.SrfSplashed)
                    {
                        itemInfo[5] = "Splashed: <b><color=green>V</color> Biome Depending</b>";
                    }
                    // ищем в форматировании инфы парта в ВАБ блок который нам нужен
                    try
                    {
                        // получаем имеющийся блок с нужным заголовком (Science Experiment)
                        var infos = part.moduleInfos.Where(
                            x =>
                                x.moduleName.Equals("Science Experiment",
                                    StringComparison.InvariantCultureIgnoreCase)).ToList();

                        // если ничего нет - следующая итерация цикла
                        if (!infos.Any()) continue;  

                        // ????? получаем имеющиюся в блоке инфу
                        var d = infos.FirstOrDefault(x => x.info.Contains(string.IsNullOrEmpty(moduleScienceExperiment.experimentActionName) ? moduleScienceExperiment.experimentID : moduleScienceExperiment.experimentActionName));

                        // если ничего нет - следующая итерация цикла
                        if (d == null) continue;
                        //Debug.Log("=============================================== GO ====================================");
                        //склеиваем ???? и передаем  сформированную строку в метод подстановки
                        d.info = string.Concat(d.info, "\n", GetInfo(itemInfo));
                    }
                    catch
                    {
                        // ignored
                    }
                    //Debug.Log("=============================================== NEXT =======================================");
                }
                //Debug.Log("=============================================== foreach modules end ============================");
            }
            //Debug.Log("=============================================== foreach _partsWithScience end ============================");
        }

        //метод вызывается после формирования готового массива строк для подстановки
        private string GetInfo(string[] moduleInfos)
        {
            //Debug.Log("=============================================== moduleInfos ================================================================");
            //начинаем с перевода строки
            string data = "--------------------------------\n";
            //data = string.Concat(data, $"<b><color={XKCDColors.HexFormat.Cyan}>{moduleInfos[0]}</color></b>\n\n");
            //цикл.  подставляем готовые строки заканчивая каждую переводом строки
            foreach (string moduleInfo in moduleInfos)
            {
                data = string.Concat(data, moduleInfo + "\n");
            }
            return data;
        }
    }
}
